package org.http4s
package rho.bits

import java.text.SimpleDateFormat
import java.time.Instant
import java.util.{Date, UUID}

import cats.Monad

import scala.reflect.runtime.universe.TypeTag
import scala.util.control.NonFatal

/** Parse values from a `String`
  *
  * @tparam T
  *   The result type generated by the parser.
  */
trait StringParser[F[_], T] extends ResponseGeneratorInstances[F] {

  /** Attempt to parse the `String`. */
  def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, T]

  /** TypeTag of the type T */
  def typeTag: Option[TypeTag[T]]

  def map[U](f: T => U)(implicit ttu: TypeTag[U]): StringParser[F, U] =
    new RMappedParser[F, T, U](this, (t: T) => SuccessResponse(f(t)), ttu)

  def rmap[U](f: T => ResultResponse[F, U])(implicit ttu: TypeTag[U]): StringParser[F, U] =
    new RMappedParser[F, T, U](this, f, ttu)

  protected def invalidNumberFormat[A](n: String)(implicit F: Monad[F]): FailureResponse[F] =
    FailureResponse.pure[F] {
      BadRequest.pure(s"Invalid number format: '$n'")
    }
}

class BooleanParser[F[_]] extends StringParser[F, Boolean] {
  override val typeTag: Some[TypeTag[Boolean]] = Some(implicitly[TypeTag[Boolean]])

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Boolean] = s match {
    case "true" => SuccessResponse(true)
    case "false" => SuccessResponse(false)
    case _ => FailureResponse.pure[F](BadRequest.pure(s"Invalid boolean format: '$s'"))
  }
}

class DoubleParser[F[_]] extends StringParser[F, Double] {
  override val typeTag: Some[TypeTag[Double]] = Some(implicitly[TypeTag[Double]])

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Double] =
    try SuccessResponse(s.toDouble)
    catch { case _: NumberFormatException => invalidNumberFormat[Double](s) }
}

class FloatParser[F[_]] extends StringParser[F, Float] {
  override val typeTag: Some[TypeTag[Float]] = Some(implicitly[TypeTag[Float]])

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Float] =
    try SuccessResponse(s.toFloat)
    catch { case _: NumberFormatException => invalidNumberFormat[Float](s) }
}

class IntParser[F[_]] extends StringParser[F, Int] {
  override val typeTag: Some[TypeTag[Int]] = Some(implicitly[TypeTag[Int]])

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Int] =
    try SuccessResponse(s.toInt)
    catch { case _: NumberFormatException => invalidNumberFormat[Int](s) }
}

class LongParser[F[_]] extends StringParser[F, Long] {
  override val typeTag: Some[TypeTag[Long]] = Some(implicitly[TypeTag[Long]])

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Long] =
    try SuccessResponse(s.toLong)
    catch { case _: NumberFormatException => invalidNumberFormat[Long](s) }
}

class ShortParser[F[_]] extends StringParser[F, Short] {
  override val typeTag: Some[TypeTag[Short]] = Some(implicitly[TypeTag[Short]])

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Short] =
    try SuccessResponse(s.toShort)
    catch { case _: NumberFormatException => invalidNumberFormat[Short](s) }
}

class DateParser[F[_]] extends StringParser[F, Date] {
  override val typeTag = Some(implicitly[TypeTag[Date]])

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Date] =
    try {
      val df = new SimpleDateFormat("yyyy-MM-dd")
      SuccessResponse(df.parse(s))
    } catch {
      case NonFatal(_) =>
        FailureResponse.pure[F] {
          BadRequest.pure(s"Invalid date format, should be 'yyyy-MM-dd': $s")
        }
    }
}

class InstantParser[F[_]] extends StringParser[F, Instant] {
  override val typeTag = Some(implicitly[TypeTag[Instant]])

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Instant] =
    try SuccessResponse(Instant.parse(s))
    catch {
      case NonFatal(_) =>
        FailureResponse.pure[F] {
          BadRequest.pure(s"Invalid instant format, should be in 'yyyy-MM-ddThh:mm:ssZ' format: $s")
        }
    }
}

class UUIDParser[F[_]] extends StringParser[F, UUID] {
  override val typeTag = Some(implicitly[TypeTag[UUID]])

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, UUID] =
    try SuccessResponse(UUID.fromString(s))
    catch {
      case NonFatal(_) =>
        FailureResponse.pure[F] {
          BadRequest.pure(s"Invalid uuid format: $s")
        }
    }
}

private class RMappedParser[F[_], T, U](
    base: StringParser[F, T],
    f: T => ResultResponse[F, U],
    ttu: TypeTag[U])
    extends StringParser[F, U] {
  override def typeTag: Option[TypeTag[U]] = Some(ttu)

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, U] =
    base.parse(s).flatMap(f)
}

object StringParser {

  // //////////////////// Default parsers //////////////////////////////

  implicit def booleanParser[F[_]]: BooleanParser[F] = new BooleanParser[F]()
  implicit def doubleParser[F[_]]: DoubleParser[F] = new DoubleParser[F]()
  implicit def floatParser[F[_]]: FloatParser[F] = new FloatParser[F]()
  implicit def intParser[F[_]]: IntParser[F] = new IntParser[F]()
  implicit def longParser[F[_]]: LongParser[F] = new LongParser[F]()
  implicit def shortParser[F[_]]: ShortParser[F] = new ShortParser[F]()
  implicit def dateParser[F[_]]: DateParser[F] = new DateParser[F]()
  implicit def instantParser[F[_]]: InstantParser[F] = new InstantParser[F]()
  implicit def uuidParser[F[_]]: UUIDParser[F] = new UUIDParser[F]()

  implicit def strParser[F[_]]: StringParser[F, String] = new StringParser[F, String] {

    override val typeTag: Some[TypeTag[String]] = Some(implicitly[TypeTag[String]])

    override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, String] =
      SuccessResponse(s)
  }
}
